<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            position: fixed;
            left: 0;
            top: 0;
        }
    </style>
</head>

<body>
    <script type="module">
        import { Gol, Game, graphics, glMatrix, math } from "../../dist/goliath.js";
        const { Shader, ShaderInstance, PerspectiveCamera, OrthographicCamera, Drawable, Texture, Sprite, TextDrawable, ParticleSystem } = graphics;
        const { Quad, Cube, Plane, Sphere } = graphics.meshes;
        const { quat, vec3, vec4, mat4 } = glMatrix;
        const { MathUtils, LinearSpline } = math;

        class FireParticleSystem extends ParticleSystem {

            constructor(params) {
                super(params);

                this.accTime = 0;
                this.parent = params.parent;
                this.camera = params.camera;

                this.shader.setUniform("pointMultiplier", Gol.graphics.height * 0.28);

                this.sizeSpline = new LinearSpline(MathUtils.lerp);
                this.sizeSpline.addPoint(0.0, 1.0);
                this.sizeSpline.addPoint(0.5, 5.0);
                this.sizeSpline.addPoint(1.0, 10.0);

                this.alphaSpline = new LinearSpline(MathUtils.lerp);
                this.alphaSpline.addPoint(0.0, 0.0);
                this.alphaSpline.addPoint(0.1, 1.0);
                this.alphaSpline.addPoint(0.6, 1.0);
                this.alphaSpline.addPoint(1.0, 0.0);

                this.colorSpline = new LinearSpline((x, a, b) => vec3.lerp(vec3.create(), a, b, x));
                this.colorSpline.addPoint(0.0, [1, 1, 0.5]);
                this.colorSpline.addPoint(1.0, [1, 0.5, 0.5]);
            }

            addParticles() {

                const delta = Gol.graphics.delta;

                this.accTime += delta;

                const n = Math.floor(this.accTime * 50);
                this.accTime -= n / 50;

                for (let i = 0; i < n; ++i) {
                    const life = MathUtils.rand(0.25, 1) * 2;
                    const pos = [
                        MathUtils.rand(-1, 1) * 1,
                        MathUtils.rand(-1, 1) * 1,
                        MathUtils.rand(-1, 1) * 1
                    ];
                    const vel = [0, 15, 0];
                    const m = mat4.fromQuat(mat4.create(), this.parent.rotation);
                    vec3.transformMat4(pos, pos, m);
                    vec3.add(pos, pos, this.parent.position)
                    this.particles.push({
                        position: pos,
                        baseSize: MathUtils.rand(0.5, 1) * 4,
                        life: life,
                        maxLife: life,
                        velocity: vec3.transformMat4(vel, vel, m),
                        color: [1, 1, 1],
                        alpha: 0.1
                    });
                }
            }

            updateParticles() {

                const delta = Gol.graphics.delta;

                for (let p of this.particles) {
                    p.life -= delta;
                }

                this.particles = this.particles.filter(p => p.life > 0);

                for (let p of this.particles) {
                    const t = 1 - p.life / p.maxLife;

                    p.alpha = this.alphaSpline.getValue(t);
                    p.size = p.baseSize * this.sizeSpline.getValue(t);
                    vec3.copy(p.color, this.colorSpline.getValue(t));

                    vec3.scaleAndAdd(p.position, p.position, p.velocity, delta);

                    const drag = vec3.clone(p.velocity);
                    vec3.scale(drag, drag, delta * 0.1);
                    drag[1] = Math.sign(p.velocity[1]) * Math.min(Math.abs(drag[1]), Math.abs(p.velocity[1]));
                    vec3.sub(p.velocity, p.velocity, drag);
                }

                this.particles.sort((a, b) => {
                    const d1 = vec3.dist(this.camera.position, a.position);
                    const d2 = vec3.dist(this.camera.position, b.position);
                    return d2 - d1;
                });

            }

        }


        class MyFirstGame extends Game {

            constructor() {
                super();
            }

            preload() {
                Gol.files.loadImage("player", "player.png");
                Gol.files.loadImage("grass-block", "grass-block.png");
                Gol.files.loadImage("fire", "fire.png");
                Gol.files.loadImage("ground", "ground.png");
                Gol.files.loadAudio("bgmusic", "bgmusic.mp3");
            }

            create() {

                Gol.audio.playBgMusic("bgmusic");

                this.camera = new PerspectiveCamera(60, Gol.graphics.width, Gol.graphics.height, 0.1, 2000);
                this.camera.position[1] = 2;
                this.camera.position[2] = 5;

                this.mouse = {
                    x: null,
                    y: null
                };

                const widthSegments = 100;
                const depthSegments = 100;
                const heightMap = [...new Array(depthSegments + 1)].map(e => [...new Array(widthSegments + 1)].fill(0));
                for(let i = 0; i < 100; ++i) {
                    const x = MathUtils.randInt(0, widthSegments);
                    const z = MathUtils.randInt(0, depthSegments);
                    const h = MathUtils.rand(0, 20);
                    for(let j = 0; j <= depthSegments; ++j) {
                        for(let k = 0; k <= widthSegments; ++k) {
                            const dist = Math.hypot(j - z, k - x);
                            heightMap[j][k] += Math.sign(h) * Math.abs(h / (2 ** dist));
                        }
                    }
                }

                this.groundTexture = new Texture(Gol.files.get("ground"), {
                        filter: Gol.gl.LINEAR_MIPMAP_LINEAR
                    });

                this.plane = new Drawable(
                    new Plane({
                        width: 500,
                        depth: 500,
                        widthSegments: widthSegments,
                        depthSegments: depthSegments,
                        heightMap: heightMap,
                        textureRepeat: true
                    }),
                    new ShaderInstance(Gol.graphics.getShader("texture")),
                    this.groundTexture
                );

                const colorSpline = new LinearSpline((x, a, b) => vec4.lerp(vec4.create(), a, b, x));
                colorSpline.addPoint(0, [0, 0.7, 0.8, 1]);
                colorSpline.addPoint(0.5, [0.8, 0.95, 0.95, 1]);

                this.sphere = new Drawable(
                    new Sphere({
                        radius: 1000,
                        colors: colorSpline
                    }),
                    new ShaderInstance(Gol.graphics.getShader("simple")),
                    null
                );
            }

            resize(width, height) {
                this.camera.viewportWidth = width;
                this.camera.viewportHeight = height;
                this.camera.updateProjection();
            }

            render(delta) {

                if(Gol.input.isMouseClicked()) {
                    this.mouse.x = Gol.input.getX();
                    this.mouse.y = Gol.input.getY();
                }
                if(Gol.input.isMousePressed()) {
                    const x = Gol.input.getX();
                    const y = Gol.input.getY();
                    vec3.rotateY(this.camera.direction, this.camera.direction, this.camera.up, (this.mouse.x - x) * 0.005);
                    this.camera.direction[1] += (this.mouse.y - y) * 0.005;
                    this.mouse.x = x;
                    this.mouse.y = y;
                }

                const translation = vec3.create();

                if(Gol.input.isKeyPressed("KeyW")) {
                    const front = this.camera.direction;
                    vec3.add(translation, translation, [front[0], 0, front[2]]);
                }

                if(Gol.input.isKeyPressed("KeyS")) {
                    const front = this.camera.direction;
                    vec3.add(translation, translation, [-front[0], 0, -front[2]]);
                }

                if(Gol.input.isKeyPressed("KeyA")) {
                    const right = this.camera.getRight();
                    vec3.add(translation, translation, [-right[0], 0, -right[2]]);
                }

                if(Gol.input.isKeyPressed("KeyD")) {
                    const right = this.camera.getRight();
                    vec3.add(translation, translation, [right[0], 0, right[2]]);
                }

                vec3.scaleAndAdd(this.camera.position, this.camera.position, translation, delta * 5);

                const constants = {
                    "ambientColor": [1, 1, 1]
                };

                this.camera.updateConstants(constants);

                Gol.gl.viewport(0, 0, Gol.graphics.width, Gol.graphics.height);

                Gol.gl.clearColor(0, 0, 0, 1);
                Gol.gl.clear(Gol.gl.COLOR_BUFFER_BIT | Gol.gl.DEPTH_BUFFER_BIT);

                Gol.gl.enable(Gol.gl.DEPTH_TEST);
                Gol.gl.disable(Gol.gl.BLEND);

                this.plane.draw(constants);
                this.sphere.draw(constants);
            }

        }

        addEventListener("DOMContentLoaded", () => {
            Gol.init(new MyFirstGame());
        });
    </script>
</body>

</html>